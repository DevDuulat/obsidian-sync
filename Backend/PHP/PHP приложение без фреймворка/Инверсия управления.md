**Введение в инверсию управления**
В последней части вы создали класс контроллера и выводили данные с помощью `echo`. Но у нас есть удобная объектно-ориентированная абстракция HTTP, и сейчас она недоступна внутри вашего класса.

**Что такое инверсия управления?**
Инверсия управления (IoC) — это принцип, согласно которому вместо того, чтобы класс сам создавал необходимые ему объекты, вы предоставляете эти объекты через внедрение зависимостей (dependency injection). 

Не волнуйтесь, если это кажется сложным. Просто следуйте шагам в этом туториале, и всё станет понятным.

### Обновление контроллера

Измените ваш контроллер `Homepage` следующим образом:

```php
<?php declare(strict_types = 1);

namespace Example\Controllers;

use Http\Response;

class Homepage
{
    private $response;

    public function __construct(Response $response)
    {
        $this->response = $response;
    }

    public function show()
    {
        $this->response->setContent('Hello World');
    }
}
```

Обратите внимание на импорт `Http\Response` вверху файла. Это позволяет использовать класс `Response` без указания полного имени.

В конструкторе мы теперь явно запрашиваем объект `Http\Response`. В данном случае `Http\Response` — это интерфейс, и любой класс, реализующий этот интерфейс, может быть внедрён.

### Обновление Bootstrap.php

Поскольку мы не внедряем ничего, текущий код вызовет ошибку. Исправим это в `Bootstrap.php`, где происходит обработка маршрутов:

```php
$class = new $className($response);
$class->$method($vars);
```

Объект `Http\HttpResponse` реализует интерфейс `Http\Response`, поэтому он подходит под контракт и может быть использован.

### Проверка работоспособности

Теперь всё должно работать снова. При переходе на [http://localhost:8000/](http://localhost:8000/) вы должны увидеть "Hello World". Если нет, проверьте и отладьте код.

### Заключение

Не забудьте зафиксировать изменения в вашем репозитории! В следующей части мы обсудим, как избежать внедрения одних и тех же объектов во все классы.